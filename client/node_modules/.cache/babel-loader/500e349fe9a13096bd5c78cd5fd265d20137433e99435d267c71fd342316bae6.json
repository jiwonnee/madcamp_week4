{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\USER\\\\Documents\\\\MadCamp\\\\madcamp_week4\\\\client\\\\src\\\\component\\\\swissPages\\\\RoundInfo.js\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport React, { createContext, useContext, useState } from \"react\";\nimport { usePlayer } from \"./PlayerInfo\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst RoundContext = /*#__PURE__*/createContext();\nexport const RoundProvider = ({\n  children\n}) => {\n  _s();\n  const {\n    players,\n    addOppFromRound,\n    updateResFromMatch\n  } = usePlayer();\n  const [rounds, setRound] = useState([]);\n  function shuffleArray(array) {\n    // 배열을 랜덤하게 섞는 함수\n    return array.sort(() => Math.random() - 0.5);\n  }\n  function groupAndShufflePlayers(players) {\n    // 승수에 따라 player 객체를 그룹화\n    const groupedByWins = players.reduce((acc, player) => {\n      (acc[player.win] = acc[player.win] || []).push(player);\n      return acc;\n    }, {});\n\n    // 그룹화된 객체의 키(승수)를 기준으로 정렬\n    const sortedKeys = Object.keys(groupedByWins).sort((a, b) => b - a); // 오름차순 정렬\n    // const sortedKeys = Object.keys(groupedByWins).sort((a, b) => b - a); // 내림차순 정렬\n\n    // 정렬된 순서대로 각 그룹을 랜덤하게 섞고, 하나의 배열로 합침\n    const shuffledPlayers = sortedKeys.reduce((acc, key) => {\n      const shuffledGroup = shuffleArray(groupedByWins[key]);\n      return [...acc, ...shuffledGroup];\n    }, []);\n    return shuffledPlayers;\n  }\n  function makeNewRound() {\n    let newRound = [];\n    let matchedIds = new Set();\n    let cnt = 0;\n    let dropNum = 0;\n    let tmpPlayers = groupAndShufflePlayers(players);\n    //console.log(tmpPlayers);\n    while (1) {\n      for (let i = 0; i < players.length; i++) {\n        if (matchedIds.has(tmpPlayers[i].id)) continue;\n        if (tmpPlayers[i].state === false) {\n          dropNum = dropNum + 1;\n          continue;\n        }\n        for (let j = i + 1; j < players.length; j++) {\n          if (matchedIds.has(tmpPlayers[j].id)) continue;\n          if (tmpPlayers[j].state === false) continue;\n          if (!tmpPlayers[i].opponentId.includes(tmpPlayers[j].id)) {\n            newRound.push({\n              player1: tmpPlayers[i],\n              player2: tmpPlayers[j],\n              player1Res: 1,\n              player2Res: 1,\n              matchNum: newRound.length + 1\n            });\n            matchedIds.add(tmpPlayers[i].id);\n            matchedIds.add(tmpPlayers[j].id);\n            break;\n          }\n        }\n      }\n      if (matchedIds.size + (tmpPlayers.length - dropNum) % 2 === tmpPlayers.length - dropNum) break;else {\n        newRound = [];\n        matchedIds = new Set();\n        tmpPlayers = groupAndShufflePlayers(players);\n        dropNum = 0;\n        cnt++;\n      }\n      if (cnt > 50) return -1;\n    }\n    for (let i = 0; i < players.length; i++) {\n      if (!matchedIds.has(tmpPlayers[i].id) && tmpPlayers[i].state) {\n        const nonePlayer = {\n          id: -1,\n          name: \"X\",\n          state: false,\n          rank: -1,\n          win: -1,\n          loss: -1,\n          score: -1,\n          buchholz: -1,\n          maxWinStreak: -1,\n          winStreakStartRound: -1,\n          opponentId: [],\n          matchResult: []\n        };\n        newRound.push({\n          player1: tmpPlayers[i],\n          player2: nonePlayer,\n          player1Res: 2,\n          player2Res: 0,\n          matchNum: newRound.length + 1\n        });\n      }\n    }\n    return newRound;\n  }\n  const addRound = () => {\n    const newRound = makeNewRound();\n    if (newRound === -1) return -1;\n    addOppFromRound(newRound);\n    const RoundElement = {\n      round: newRound,\n      num: rounds.length + 1\n    };\n    //console.log(RoundElement);\n    setRound([...rounds, RoundElement]);\n  };\n  const removeRound = num => {\n    setRound(rounds.filter(r => r.num !== num));\n  };\n  const updateMatch = (num, matchNum, newRes) => {\n    updateResFromMatch(num, newRes);\n    setRound(rounds.map((round, roundIndex) => {\n      if (roundIndex !== num - 1) return round;\n      const updatedRound = round.round.map(match => match.matchNum === matchNum ? newRes : match);\n      return {\n        round: updatedRound,\n        num: round.num\n      };\n    }));\n  };\n  const value = {\n    rounds,\n    addRound,\n    removeRound,\n    updateMatch\n  };\n  return /*#__PURE__*/_jsxDEV(RoundContext.Provider, {\n    value: value,\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 130,\n    columnNumber: 9\n  }, this);\n};\n_s(RoundProvider, \"AoybEV4xuFxpJTIY3BgpcFABQg4=\", false, function () {\n  return [usePlayer];\n});\n_c = RoundProvider;\nexport const useRound = () => {\n  _s2();\n  return useContext(RoundContext);\n};\n_s2(useRound, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\nvar _c;\n$RefreshReg$(_c, \"RoundProvider\");","map":{"version":3,"names":["React","createContext","useContext","useState","usePlayer","jsxDEV","_jsxDEV","RoundContext","RoundProvider","children","_s","players","addOppFromRound","updateResFromMatch","rounds","setRound","shuffleArray","array","sort","Math","random","groupAndShufflePlayers","groupedByWins","reduce","acc","player","win","push","sortedKeys","Object","keys","a","b","shuffledPlayers","key","shuffledGroup","makeNewRound","newRound","matchedIds","Set","cnt","dropNum","tmpPlayers","i","length","has","id","state","j","opponentId","includes","player1","player2","player1Res","player2Res","matchNum","add","size","nonePlayer","name","rank","loss","score","buchholz","maxWinStreak","winStreakStartRound","matchResult","addRound","RoundElement","round","num","removeRound","filter","r","updateMatch","newRes","map","roundIndex","updatedRound","match","value","Provider","fileName","_jsxFileName","lineNumber","columnNumber","_c","useRound","_s2","$RefreshReg$"],"sources":["C:/Users/USER/Documents/MadCamp/madcamp_week4/client/src/component/swissPages/RoundInfo.js"],"sourcesContent":["import React, { createContext, useContext, useState } from \"react\";\r\nimport { usePlayer } from \"./PlayerInfo\";\r\n\r\nconst RoundContext = createContext();\r\n\r\nexport const RoundProvider = ({ children }) => {\r\n    const { players, addOppFromRound, updateResFromMatch } = usePlayer();\r\n\r\n    const [rounds, setRound] = useState([]);\r\n\r\n    function shuffleArray(array) {\r\n        // 배열을 랜덤하게 섞는 함수\r\n        return array.sort(() => Math.random() - 0.5);\r\n    }\r\n    \r\n    function groupAndShufflePlayers(players) {\r\n        // 승수에 따라 player 객체를 그룹화\r\n        const groupedByWins = players.reduce((acc, player) => {\r\n            (acc[player.win] = acc[player.win] || []).push(player);\r\n            return acc;\r\n        }, {});\r\n    \r\n        // 그룹화된 객체의 키(승수)를 기준으로 정렬\r\n        const sortedKeys = Object.keys(groupedByWins).sort((a, b) => b - a); // 오름차순 정렬\r\n        // const sortedKeys = Object.keys(groupedByWins).sort((a, b) => b - a); // 내림차순 정렬\r\n    \r\n        // 정렬된 순서대로 각 그룹을 랜덤하게 섞고, 하나의 배열로 합침\r\n        const shuffledPlayers = sortedKeys.reduce((acc, key) => {\r\n            const shuffledGroup = shuffleArray(groupedByWins[key]);\r\n            return [...acc, ...shuffledGroup];\r\n        }, []);\r\n    \r\n        return shuffledPlayers;\r\n    }\r\n    \r\n\r\n    function makeNewRound(){\r\n        let newRound = [];\r\n        let matchedIds = new Set();\r\n        let cnt = 0;\r\n        let dropNum = 0;\r\n\r\n        let tmpPlayers = groupAndShufflePlayers(players);\r\n        //console.log(tmpPlayers);\r\n        while(1){\r\n            for(let i = 0; i < players.length; i++){\r\n                if(matchedIds.has(tmpPlayers[i].id)) continue;\r\n                if(tmpPlayers[i].state === false) {dropNum = dropNum + 1; continue;}\r\n                for(let j = i + 1; j < players.length; j++){\r\n                    if(matchedIds.has(tmpPlayers[j].id)) continue;\r\n                    if(tmpPlayers[j].state === false) continue;\r\n    \r\n                    if(!tmpPlayers[i].opponentId.includes(tmpPlayers[j].id)){\r\n                        newRound.push({player1: tmpPlayers[i], player2: tmpPlayers[j], player1Res: 1, player2Res: 1, matchNum: newRound.length + 1});\r\n                        matchedIds.add(tmpPlayers[i].id);\r\n                        matchedIds.add(tmpPlayers[j].id);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            if(matchedIds.size + ((tmpPlayers.length - dropNum) % 2) === tmpPlayers.length - dropNum) break;\r\n            else {\r\n                newRound = [];\r\n                matchedIds = new Set();\r\n                tmpPlayers = groupAndShufflePlayers(players);\r\n                dropNum = 0;\r\n                cnt++;\r\n            }\r\n\r\n            if(cnt > 50) return -1;\r\n        }\r\n\r\n        \r\n\r\n        for(let i = 0; i < players.length; i++){\r\n            if(!matchedIds.has(tmpPlayers[i].id) && tmpPlayers[i].state){\r\n                const nonePlayer = {\r\n                    id: -1,\r\n                    name: \"X\",\r\n                    state: false,\r\n                    rank: -1,\r\n                    win: -1,\r\n                    loss: -1,\r\n                    score: -1,\r\n                    buchholz: -1,\r\n                    maxWinStreak: -1,\r\n                    winStreakStartRound: -1,\r\n                    opponentId: [],\r\n                    matchResult: [],\r\n                }\r\n                newRound.push({player1: tmpPlayers[i], player2: nonePlayer, player1Res: 2, player2Res: 0, matchNum: newRound.length + 1});\r\n            }\r\n        }\r\n        return newRound;\r\n    }\r\n\r\n    const addRound = () => {\r\n        const newRound = makeNewRound();\r\n        if(newRound === -1) return -1;\r\n        addOppFromRound(newRound);\r\n        const RoundElement = {round: newRound, num: rounds.length + 1};\r\n        //console.log(RoundElement);\r\n        setRound([...rounds, RoundElement]);\r\n    }\r\n\r\n    const removeRound = (num) => {\r\n        setRound(rounds.filter(r => r.num !== num));\r\n    };\r\n\r\n    const updateMatch = (num, matchNum, newRes) => {\r\n        updateResFromMatch(num, newRes);\r\n        setRound(rounds.map((round, roundIndex) => {\r\n            if(roundIndex !== num - 1) return round;\r\n            const updatedRound = round.round.map((match) =>\r\n                match.matchNum === matchNum? newRes : match\r\n            );\r\n            return {round: updatedRound, num: round.num};\r\n        }));\r\n           \r\n    }\r\n\r\n    const value = {\r\n        rounds,\r\n        addRound,\r\n        removeRound,\r\n        updateMatch,\r\n    }\r\n\r\n    return (\r\n        <RoundContext.Provider value={value}>\r\n            { children }\r\n        </RoundContext.Provider>\r\n    )\r\n};\r\n\r\nexport const useRound = () => useContext(RoundContext);"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}